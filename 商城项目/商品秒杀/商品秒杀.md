在微服务系统中，商品秒杀模块是典型的高并发场景（如“秒杀活动”“限时抢购”），其核心特点是**短时间内流量激增（数十万甚至数百万QPS）、库存有限（通常少量商品）、业务逻辑简单但性能要求极高**。设计时需重点解决**超卖、系统过载、流量削峰**等问题，同时保证用户体验。以下是具体设计方案及注意点：


### 一、整体架构设计
秒杀模块需独立于普通商品/订单流程，避免高并发流量冲击核心业务。典型架构如下：

```
用户 → CDN → 前端页面 → API网关 → 秒杀服务 → 缓存（Redis） → 消息队列 → 订单/库存服务 → 数据库
                          ↓                    ↓
                        限流/降级             库存预扣减
```

#### 核心子服务拆分
| 子服务         | 核心职责                                  | 技术重点                     |
|----------------|-------------------------------------------|------------------------------|
| 秒杀活动服务   | 管理秒杀活动（创建、上下架、时间控制）、商品关联 | 活动状态缓存、时间校验       |
| 秒杀接口服务   | 处理抢购请求、库存预扣减、生成预订单        | 高并发处理、限流、防超卖     |
| 订单履约服务   | 处理秒杀订单支付、取消、库存最终扣减        | 异步处理、幂等性保证         |


### 二、核心流程设计
秒杀流程需极致简化（避免复杂业务逻辑），核心步骤如下：

#### 1. 活动预热阶段（秒杀前）
- **库存预加载**：秒杀活动开始前（如提前10分钟），将秒杀商品库存从数据库同步到Redis（如`seckill:stock:{productId} = 100`），减少活动期间的DB访问。  
- **活动信息缓存**：将秒杀商品信息（ID、名称、秒杀价、开始/结束时间）缓存到Redis和CDN，前端直接从CDN获取，减少服务端请求。  
- **前端静态化**：秒杀页面静态化（HTML+CSS+JS），通过CDN分发，避免动态渲染耗时。  


#### 2. 用户抢购阶段（秒杀中）
```
用户点击“抢购” → 前端限流（按钮置灰、防重复点击）  
→ API网关限流（如单IP 10秒内最多3次请求）  
→ 秒杀接口服务校验（活动是否开始/结束、用户是否已抢购）  
→ Redis预扣减库存（原子操作，避免超卖）  
→ 预扣减成功 → 发送消息到队列（生成订单）  
→ 返回“抢购成功，正在生成订单”给用户  
→ 队列消费者处理订单（扣减DB库存、创建订单）  
→ 通知用户订单结果（短信/APP推送）
```


#### 3. 订单处理阶段（秒杀后）
- **订单生成**：消息队列异步处理订单创建（避免同步处理阻塞接口），限制订单支付时间（如5分钟内未支付则取消并释放库存）。  
- **库存最终扣减**：从Redis同步预扣减结果到数据库，用乐观锁保证一致性（`UPDATE seckill_stock SET quantity = quantity - 1 WHERE product_id = ? AND quantity > 0`）。  
- **失败补偿**：若订单创建失败（如DB异常），通过定时任务从Redis与DB的库存差异中恢复（释放Redis中已扣减但未实际下单的库存）。  


### 三、关键技术方案
#### 1. 防超卖设计（核心！）
超卖是秒杀最致命的问题，需从**缓存层、数据库层、业务层**三重防护：  
- **Redis原子操作**：用`DECR`命令预扣减库存，仅当返回值≥0时视为抢购成功（避免并发扣减导致负数）。示例：  
  ```java
  // Lua脚本保证原子性（判断库存是否充足 + 扣减库存）
  String luaScript = "if tonumber(redis.call('get', KEYS[1])) > 0 then " +
                     "return redis.call('decr', KEYS[1]) " +
                     "else return -1 end";
  // 执行脚本，KEYS[1]为库存键：seckill:stock:{productId}
  Long result = redisTemplate.execute(
      new DefaultRedisScript<>(luaScript, Long.class),
      Collections.singletonList("seckill:stock:" + productId),
      null
  );
  if (result != null && result >= 0) {
      // 库存扣减成功，进入下单流程
  } else {
      // 库存不足，返回秒杀失败
  }
  ```  
- **数据库兜底**：Redis预扣减后，DB最终扣减时用乐观锁（`WHERE quantity > 0`），防止Redis与DB数据不一致导致的超卖。  
- **库存隔离**：秒杀库存与普通库存物理隔离（单独表`seckill_stock`），避免影响普通商品库存。  


#### 2. 流量削峰与限流
秒杀流量是常态的10-100倍，需通过多层限流控制请求量：  
- **前端限流**：  
  - 按钮置灰：点击后立即置灰，防止用户重复点击（如3秒内不可再次点击）。  
  - 验证码/排队：加入图形验证码或“排队中”提示，分散请求峰值（本质是增加用户操作耗时）。  
- **API网关限流**：  
  - 基于IP限流：如Nginx配置`limit_req_zone $binary_remote_addr zone=seckill:10m rate=10r/s;`（单IP每秒最多10次请求）。  
  - 基于用户ID限流：登录用户通过`user_id`限制（如单用户只能抢购1次），未登录用户拒绝（避免匿名刷单）。  
- **服务端限流**：  
  - 令牌桶算法：用Guava的`RateLimiter`或Redis实现，限制服务处理能力（如每秒处理10000个请求）。  
  - 过载保护：当系统负载（CPU>80%、内存>90%）时，直接返回“系统繁忙”，保护核心服务。  


#### 3. 异步化处理
秒杀接口需“快进快出”，避免同步处理耗时操作：  
- **请求异步化**：抢购请求校验通过后，立即返回“排队中”，实际订单处理通过消息队列（如RabbitMQ）异步执行。  
- **结果异步通知**：订单处理完成后，通过WebSocket、短信或APP推送通知用户（避免用户长时间等待）。  


#### 4. 缓存设计
- **多级缓存**：  
  - 本地缓存（Caffeine）：存储活动基本信息（如是否开始），减少Redis访问。  
  - Redis缓存：存储秒杀库存、用户抢购记录（如`seckill:user:{productId}:{userId} = 1`，防止重复抢购）。  
- **缓存预热**：活动开始前批量加载数据到缓存，避免活动开始时的“缓存穿透”（大量请求直击DB）。  
- **防缓存穿透**：对不存在的商品ID，缓存空值（如`seckill:stock:9999 = 0`），并设置短期过期时间。  


### 四、注意点
#### 1. 避免重复抢购
- 用Redis记录用户抢购状态：`seckill:user:{productId}:{userId}`，存在则拒绝再次抢购。  
- 订单表加唯一索引：`UNIQUE KEY uk_user_product (user_id, product_id)`，防止因消息队列重试导致的重复下单。  


#### 2. 库存一致性
- **Redis与DB同步**：活动结束后，以DB库存为准，清理Redis残留数据（避免下次活动受影响）。  
- **异常补偿**：定时任务对比Redis预扣减库存与DB实际扣减库存，差异部分（如Redis扣减但DB未扣减）视为“无效抢购”，释放Redis库存。  


#### 3. 高可用设计
- **服务集群**：秒杀服务、Redis、消息队列均集群部署（如Redis主从+哨兵，RabbitMQ镜像集群），避免单点故障。  
- **降级策略**：当非核心依赖（如用户画像服务）故障时，临时关闭相关功能（如不校验用户等级），优先保证抢购流程可用。  
- **熔断隔离**：用Resilience4j或Sentinel隔离秒杀服务与其他服务，防止秒杀服务故障蔓延至核心业务（如普通订单）。  


#### 4. 防作弊与安全
- **防脚本抢购**：校验用户UA（排除非浏览器请求）、检查请求频率（异常高频IP加入黑名单）、强制登录（绑定用户身份）。  
- **接口签名**：秒杀接口加入时间戳+签名（如`sign = MD5(appKey + timestamp + nonce)`），防止接口被伪造调用。  
- **库存隐藏**：前端不实时显示剩余库存（或显示模糊值如“库存紧张”），避免用户根据库存变化恶意刷单。  


#### 5. 监控与复盘
- **实时监控**：监控Redis库存、接口QPS、队列堆积量、DB压力，设置阈值告警（如队列堆积>10万则扩容）。  
- **日志埋点**：记录关键节点日志（如“预扣减成功”“订单创建失败”），便于事后复盘超卖、漏单等问题。  
- **压测验证**：活动前通过JMeter模拟高并发（如10万QPS），验证系统瓶颈（如Redis性能、DB连接数）。  


### 五、示例代码（秒杀接口核心逻辑）
```java
@Service
public class SeckillService {
    @Autowired
    private StringRedisTemplate redisTemplate;
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @Autowired
    private SeckillActivityRepository activityRepo;

    // 库存键前缀
    private static final String STOCK_KEY = "seckill:stock:%s";
    // 用户抢购记录键前缀
    private static final String USER_RECORD_KEY = "seckill:user:%s:%s";

    /**
     * 处理秒杀请求
     */
    public Result<String> doSeckill(Long userId, Long productId) {
        // 1. 校验活动状态（从本地缓存获取，减少Redis访问）
        SeckillActivity activity = localCache.getIfPresent("seckill:activity:" + productId);
        if (activity == null) {
            return Result.fail("活动不存在");
        }
        long now = System.currentTimeMillis();
        if (now < activity.getStartTime().getTime() || now > activity.getEndTime().getTime()) {
            return Result.fail("活动未开始或已结束");
        }

        // 2. 校验用户是否已抢购（防止重复抢购）
        String userRecordKey = String.format(USER_RECORD_KEY, productId, userId);
        Boolean hasRecord = redisTemplate.hasKey(userRecordKey);
        if (Boolean.TRUE.equals(hasRecord)) {
            return Result.fail("您已抢购过该商品");
        }

        // 3. Redis原子扣减库存（Lua脚本保证原子性）
        String stockKey = String.format(STOCK_KEY, productId);
        String luaScript = "if tonumber(redis.call('get', KEYS[1])) > 0 then " +
                           "return redis.call('decr', KEYS[1]) " +
                           "else return -1 end";
        Long remainStock = redisTemplate.execute(
            new DefaultRedisScript<>(luaScript, Long.class),
            Collections.singletonList(stockKey),
            null
        );

        // 4. 库存不足，返回失败
        if (remainStock == null || remainStock < 0) {
            return Result.fail("手慢了，商品已抢完");
        }

        // 5. 库存扣减成功，记录用户抢购记录（过期时间设为活动结束后1小时）
        redisTemplate.opsForValue().set(
            userRecordKey, "1", 
            activity.getEndTime().getTime() - now + 3600000, 
            TimeUnit.MILLISECONDS
        );

        // 6. 发送消息到队列，异步创建订单
        SeckillOrderMsg msg = new SeckillOrderMsg(userId, productId, activity.getSeckillPrice());
        rabbitTemplate.convertAndSend("seckill.order.queue", msg);

        // 7. 返回排队结果（前端轮询或等待推送）
        return Result.success("抢购成功，正在生成订单");
    }
}
```

### 总结
秒杀模块设计的核心是**“限流削峰、异步处理、防超卖”**。需通过多层限流（前端→网关→服务）控制流量，用Redis原子操作+DB乐观锁防止超卖，借助消息队列实现异步化以提升吞吐量，同时做好高可用和监控。秒杀场景的本质是“用空间换时间”（如缓存、队列），在保证系统稳定的前提下，尽可能提升用户体验（如快速反馈、减少等待）。