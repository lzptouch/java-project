在微服务系统中设计用户权限服务，核心目标是**统一管理用户权限、实现细粒度的访问控制**，并与其他微服务解耦。权限服务需支持用户-角色-权限的关联管理、动态权限校验、跨服务权限协同等功能。以下从设计思路、核心考虑点、示例代码三个方面展开说明。


### 一、设计思路与核心架构
权限服务应作为独立微服务存在，通过API向其他微服务提供权限校验能力。核心架构如下：

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│   业务微服务    │      │   权限服务      │      │   存储层        │
│ （订单/商品等） │◄────►│ （权限管理/校验）│◄────►│ （MySQL+Redis） │
└─────────────────┘      └─────────────────┘      └─────────────────┘
        ▲                        ▲
        │                        │
        ▼                        ▼
┌─────────────────┐      ┌─────────────────┐
│   API网关       │      │   SSO服务       │
│ （统一拦截校验） │      │ （用户身份认证） │
└─────────────────┘      └─────────────────┘
```

- **核心职责**：管理用户、角色、权限的关系；提供权限校验接口；支持权限动态更新。
- **依赖关系**：依赖SSO服务获取用户身份（如用户ID），向业务微服务提供权限校验结果。


### 二、核心考虑点
#### 1. 权限模型设计（RBAC模型为基础）
采用**RBAC（Role-Based Access Control，基于角色的访问控制）** 模型，通过“用户-角色-权限”三级关联实现灵活授权：
- **用户（User）**：系统使用者（如用户ID、用户名）。
- **角色（Role）**：一组权限的集合（如“管理员”“普通用户”“编辑”），简化权限分配。
- **权限（Permission）**：具体操作许可，需明确“资源+操作”（如“订单服务-查询订单”“商品服务-删除商品”）。

**扩展设计**：  
- 支持**数据级权限**（如“用户只能查看自己的订单”），需在权限中附加数据过滤规则（如`user_id = #{currentUserId}`）。  
- 支持**临时权限**（如“临时开放3天的审核权限”），需包含有效期字段。


#### 2. 权限粒度控制
权限粒度需结合业务场景设计，避免过粗（无法精准控制）或过细（管理复杂）：
- **模块级**：控制是否能访问某个服务（如“是否允许访问订单服务”）。  
- **操作级**：控制服务内的具体操作（如“订单服务-创建订单”“订单服务-取消订单”）。  
- **数据级**：控制操作能访问的数据范围（如“只能查看自己创建的订单”）。  

**建议**：基础权限按“服务+操作”设计（如`order:create`、`product:delete`），数据级权限通过业务服务结合权限规则二次过滤。


#### 3. 权限校验时机与方式
- **API网关层**：拦截所有请求，校验“模块级权限”（如是否允许访问当前服务），拦截无权限请求，减少下游压力。  
- **业务服务层**：在具体接口中校验“操作级/数据级权限”（如调用权限服务检查是否允许“删除商品”）。  
- **校验方式**：  
  - 同步校验：业务服务通过RPC/HTTP调用权限服务接口（如`hasPermission(userId, permission)`）。  
  - 异步缓存：权限服务将用户权限缓存到Redis（如`user:1:permissions = [order:create, ...]`），业务服务直接查询缓存，减少调用开销（需处理缓存一致性）。  


#### 4. 缓存与一致性设计
- **缓存策略**：将用户-权限映射关系缓存到Redis（Key：`user:{userId}:permissions`，Value：权限集合），设置合理过期时间（如30分钟）。  
- **一致性保证**：当权限变更时（如用户角色调整），主动删除旧缓存并刷新新缓存（可通过消息队列通知各服务）。  
- **缓存穿透防护**：对不存在的用户权限返回空集合，避免缓存穿透。  


#### 5. 高可用与性能
- **集群部署**：权限服务多实例部署，配合负载均衡，避免单点故障。  
- **数据库优化**：用户-角色-权限关联表建立索引（如`user_id`、`role_id`），复杂查询加缓存。  
- **限流保护**：对权限服务API设置限流（如1000 QPS），防止被业务服务压垮。  


#### 6. 安全性
- **权限数据加密**：敏感权限（如“删除用户”）的配置信息需加密存储，防止篡改。  
- **API鉴权**：权限服务接口仅允许内部微服务调用，通过服务身份认证（如mTLS）或API密钥保护。  
- **审计日志**：记录权限变更（如“用户A被分配管理员角色”）和权限校验失败事件，便于追溯安全问题。  


### 三、示例代码（核心功能实现）
以下是基于Spring Boot的权限服务核心代码，展示用户-角色-权限管理及权限校验功能。


#### 1. 数据模型（Entity）
```java
// 用户实体
@Entity
@Table(name = "sys_user")
public class User {
    @Id
    private Long id; // 与SSO中的用户ID一致
    private String username;
    // 其他字段：邮箱、状态等
}

// 角色实体
@Entity
@Table(name = "sys_role")
public class Role {
    @Id
    private Long id;
    private String roleName; // 如"ADMIN"、"USER"
    private String description;
}

// 权限实体（资源+操作）
@Entity
@Table(name = "sys_permission")
public class Permission {
    @Id
    private Long id;
    private String permissionCode; // 如"order:create"、"product:delete"
    private String resource; // 资源（服务名）：如"order"、"product"
    private String action; // 操作：如"create"、"delete"
    private String dataRule; // 数据级规则（如"user_id = #{currentUserId}"）
}

// 用户-角色关联表（多对多）
@Entity
@Table(name = "sys_user_role")
public class UserRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long userId;
    private Long roleId;
}

// 角色-权限关联表（多对多）
@Entity
@Table(name = "sys_role_permission")
public class RolePermission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long roleId;
    private Long permissionCode;
}
```


#### 2. 权限服务核心接口（Service）
```java
@Service
public class PermissionService {
    @Autowired
    private UserRoleRepository userRoleRepo;
    @Autowired
    private RolePermissionRepository rolePermRepo;
    @Autowired
    private PermissionRepository permRepo;
    @Autowired
    private StringRedisTemplate redisTemplate;

    // 缓存Key前缀
    private static final String USER_PERM_CACHE_KEY = "user:%s:permissions";

    /**
     * 获取用户的所有权限（从缓存或数据库）
     */
    public Set<String> getUserPermissions(Long userId) {
        String cacheKey = String.format(USER_PERM_CACHE_KEY, userId);
        // 1. 先查缓存
        Set<String> cachedPerms = redisTemplate.opsForSet().members(cacheKey);
        if (cachedPerms != null && !cachedPerms.isEmpty()) {
            return cachedPerms;
        }

        // 2. 缓存未命中，查数据库
        Set<String> perms = queryPermissionsFromDb(userId);

        // 3. 写入缓存（30分钟过期）
        if (!perms.isEmpty()) {
            redisTemplate.opsForSet().add(cacheKey, perms.toArray(new String[0]));
            redisTemplate.expire(cacheKey, 30, TimeUnit.MINUTES);
        }
        return perms;
    }

    /**
     * 从数据库查询用户权限（用户→角色→权限）
     */
    private Set<String> queryPermissionsFromDb(Long userId) {
        // 1. 查询用户关联的角色
        List<Long> roleIds = userRoleRepo.findByUserId(userId)
                .stream().map(UserRole::getRoleId).collect(Collectors.toList());
        if (roleIds.isEmpty()) {
            return Collections.emptySet();
        }

        // 2. 查询角色关联的权限编码
        List<Long> permIds = rolePermRepo.findByRoleIdIn(roleIds)
                .stream().map(RolePermission::getPermissionCode).collect(Collectors.toList());
        if (permIds.isEmpty()) {
            return Collections.emptySet();
        }

        // 3. 查询权限编码
        return permRepo.findByIdIn(permIds)
                .stream().map(Permission::getPermissionCode).collect(Collectors.toSet());
    }

    /**
     * 校验用户是否有指定权限
     */
    public boolean hasPermission(Long userId, String permissionCode) {
        Set<String> userPerms = getUserPermissions(userId);
        return userPerms.contains(permissionCode);
    }

    /**
     * 权限变更时，刷新用户权限缓存（如用户角色调整后调用）
     */
    @Transactional
    public void refreshUserPermissionCache(Long userId) {
        String cacheKey = String.format(USER_PERM_CACHE_KEY, userId);
        redisTemplate.delete(cacheKey); // 删除旧缓存
        // 主动加载新权限到缓存
        getUserPermissions(userId);
    }
}
```


#### 3. 权限校验接口（Controller）
供其他微服务调用，校验用户权限：
```java
@RestController
@RequestMapping("/api/permissions")
public class PermissionController {
    @Autowired
    private PermissionService permissionService;

    /**
     * 校验用户是否有指定权限
     * @param userId 用户ID（从SSO令牌中解析）
     * @param permissionCode 权限编码（如"order:create"）
     */
    @GetMapping("/check")
    public ResponseEntity<Boolean> checkPermission(
            @RequestParam Long userId,
            @RequestParam String permissionCode) {
        boolean hasPerm = permissionService.hasPermission(userId, permissionCode);
        return ResponseEntity.ok(hasPerm);
    }

    /**
     * 获取用户所有权限
     */
    @GetMapping("/user/{userId}")
    public ResponseEntity<Set<String>> getUserPermissions(@PathVariable Long userId) {
        Set<String> perms = permissionService.getUserPermissions(userId);
        return ResponseEntity.ok(perms);
    }
}
```


#### 4. 业务服务中使用权限服务（示例）
订单服务在创建订单前校验权限：
```java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate; // 调用权限服务

    /**
     * 创建订单（需校验"order:create"权限）
     */
    public Order createOrder(Long userId, OrderDTO orderDTO) {
        // 1. 调用权限服务校验权限
        boolean hasPermission = restTemplate.getForObject(
                "http://permission-service/api/permissions/check?userId=" + userId + "&permissionCode=order:create",
                Boolean.class
        );
        if (!hasPermission) {
            throw new AccessDeniedException("无创建订单权限");
        }

        // 2. 业务逻辑：创建订单
        // ...
    }
}
```


### 四、关键注意点总结
1. **权限模型灵活性**：基于RBAC设计，支持角色继承（如“超级管理员”继承“管理员”权限）和动态权限调整。  
2. **缓存一致性**：权限变更后需及时刷新缓存，可通过事件驱动（如发布“权限变更事件”）通知缓存更新。  
3. **数据级权限实现**：在业务服务中结合权限服务返回的`dataRule`（如`user_id = 123`），通过SQL/代码过滤数据。  
4. **与SSO集成**：用户ID需与SSO服务保持一致（从JWT令牌中解析），避免身份不一致导致的权限校验错误。  
5. **性能与高可用**：核心接口加缓存、服务集群部署、数据库读写分离，确保权限服务不成为系统瓶颈。  

通过以上设计，权限服务可在微服务架构中实现统一、灵活、高性能的权限管理，同时与其他服务解耦，支持系统的可扩展性。